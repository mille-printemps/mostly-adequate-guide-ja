# 第 3 章: 純粋な関数による純粋な幸福

## 純粋であるために再び

我々が頭に叩き込まなければならないことの一つは純粋関数の理念です。

>純粋関数とは、同じ入力が与えられれば常に同じ出力を返しかつ可観察な副作用がない関数である。

`slice` と `splice` を見てみましょう。これらは全く同じことをする関数。全く異なる方法で同じことをする 2 つの関数です。入力に対し同じ出力を返すので `slice` は *純粋* と言われます。しかしながら `splice` は配列を噛み潰して吐き出し、永遠に変えてしまいます。これは可観測な作用です。

```js
const xs = [1,2,3,4,5];

// 純粋
xs.slice(0,3); // [1,2,3]

xs.slice(0,3); // [1,2,3]

xs.slice(0,3); // [1,2,3]


// 不純
xs.splice(0,3); // [1,2,3]

xs.splice(0,3); // [4,5]

xs.splice(0,3); // []
```

関数型プログラミングではデータを *変更する* `splice` のような扱いにくい関数を嫌います。.我々が `splice` のように実行された後に混乱を残すような関数ではなく、毎回同じ結果を返す信頼できる関数を目指すようなことはないでしょう。

他の例を見てみましょう。

```js
// 不純
let minimum = 21;
const checkAge = age => age >= minimum;

// 純粋
const checkAge = (age) => {
  const minimum = 21;
  return age >= minimum;
};
```

不純な部分では、`checkAge` は可変な変数 `minimum` に依存して結果を決定します。言い換えれば結果はシステムの状態に依存します。これは残念なことに外部の環境を導入することにより[認知的負荷](https://en.wikipedia.org/wiki/Cognitive_load) を増やしています。

この例ではそれほどそうは見えませんが、この状態への依存はシステムを複雑にする最も大きな要因の一つです (http://curtclifton.net/papers/MoseleyMarks06a.pdf)。この `checkAge` は入力とは別の外的な要因に依存して異なる結果を返すかも知れず、純粋ではないばかりか、そのソフトウェアについて推論するたびに我々を苦境に立たせるのです。

一方で純粋な形式は完全に自己充足的です。`minimum` を可変不可にして状態が決して変わらないようにし、その純粋さを保持することもできます。そのためには凍結されたオブジェクトを生成しなければなりません。

```js
const immutableState = Object.freeze({ minimum: 21 });
```

## 副作用が含まれるかもしれない

直感を改善するためにこれらの "副作用" についてより見てみましょう。*純粋関数* の定義において言及されているこの疑いなく極悪な *副作用* とはなんでしょう？我々は結果の計算の他にその過程で起きたあらゆるものを *作用* と呼びます。

作用は本質的には悪いことはありませんし、これから先の章の至る所で使うことになるでしょう。否定的な意味を担うのは *副* の部分です。水はそれ自体は悪ではなく悪を生み出すのはその澱みの部分です。プログラムにおいて *副* 作用は同じような悪の温床だと私は想定します。

>*副作用* はシステムの状態の変更もしくは結果の計算過程で起きる外の世界との *可観測な相互作用* である。

以下に限られてはいませんが、副作用には以下が含まれます。

  * ファイルシステムの変更
  * データベースへのレコードの挿入
  * http の呼び出し
  * 変更
  * 画面への表示 / ロギング
  * ユーザの入力の獲得
  * DOM へのクエリ
  * システムの状態へのアクセス

そしてこのリストはさらに続きます。関数の外の世界との相互作用は全て副作用で、この事実によって副作用なしで実際にプログラミングを行えるのか疑わしく思うかもしれません。関数型プログラミングの哲学では副作用は誤った動作の第一の原因であることを前提にしています。

我々は副作用を使用することを禁じられているわけではなく、むしろ制御された方法で包含し動作させたいのです。後の章で関手やモナドに行き着いたときにそれをどのように行うのかを学ぶことになりますが、ひとまず純粋関数から悪事を働く関数を分けておきましょう。

副作用により関数は *純粋* ではなくなります。これは理にかなっています: 純粋関数は定義により同じ入力に対して常に同じ出力を返さなければなりませんが、関数の外側のものを扱っている時はそれを保証することは不可能です。

我々が入力に対する出力が同じであることになぜ固執するのかより詳細に見てみましょう。襟を立ててください。中学2年の数学を見ていきます。

## 中学2年の数学

mathisfun.com から、

> 関数は数値間の特別な関係である。
> 一つひとつの入力がそれぞれ 1 つの出力をもたらす。

言い換えると関数は単に2つの数値の関係、入力と出力です。それぞれの入力は 1 つの出力を持ちますが、入力に対して出力が必ずしもユニークでなくてはならないわけではありません。以下は完璧に妥当な `x` から `y` への関数の図を表しています;

<img src="images/function-sets.gif" alt="function sets" />(https://www.mathsisfun.com/sets/function.html)

反対に入力値 `5` が複数の出力を指しているので、以下の図は関数ではない関係を表しています。

<img src="images/relation-not-function.gif" alt="relation not function" />(https://www.mathsisfun.com/sets/function.html)

関数は位置 (入力, 出力) の組の集合として記述することができます。`[(1,2), (3,6), (5,10)]` (この関数は入力を2倍にしているように見えます)。

もしくは表としても

<table> <tr> <th>Input</th> <th>Output</th> </tr> <tr> <td>1</td> <td>2</td> </tr> <tr> <td>2</td> <td>4</td> </tr> <tr> <td>3</td> <td>6</td> </tr> </table>

もしくは `x` を入力 `y` を出力としたグラフとしても記述できます。

<img src="images/fn_graph.png" width="300" height="300" alt="function graph" />

もし入力が出力を決定するのなら実装の詳細は必要ありません。関数は単に入力から出力へのマッピングになるので、オブジェクトを記述して `()` の代わりに `[]` を使って記述し呼び出すことも可能でしょう。

```js
const toLowerCase = {
  A: 'a',
  B: 'b',
  C: 'c',
  D: 'd',
  E: 'e',
  F: 'f',
};
toLowerCase['C']; // 'c'

const isPrime = {
  1: false,
  2: true,
  3: true,
  4: false,
  5: true,
  6: false,
};
isPrime[3]; // true
```

もちろん、手書きよりも計算したいかもしれませんが、これは関数について考える異なる方法を実演しています。("引数が複数ある関数についてはどうだ？" と考えるかもしれません。実際、数学的に考えた時それは少し不便です。ひとまず入力を 1 つの配列としてまとめたり、入力を `arguments` オブジェクトとして考えましょう。*カリー化* について学んだときに、関数の数学的な定義をどのように直接的に模倣できるか分かるでしょう。)

ここでドラマチックな啓示です。純粋関数 *は* 数学的な関数であり、それが関数型プログラミングということです。その観点を少し持ったプログラミングによって大きな利益を得ることができます。なぜ我々が純粋であることを保つために労を惜しまないのか理由をいくつか見てみましょう。

## 純粋の例

### キャッシュ可能性

まず初めに、純粋関数は入力によって常にキャッシュすることが可能です。これは典型的にはメモ化と呼ばれるテクニックを使います。

```js
const squareNumber = memoize(x => x * x);

squareNumber(4); // 16

squareNumber(4); // 16, 入力 4 のキャッシュを返す

squareNumber(5); // 25

squareNumber(5); // 25, 入力 5 のキャッシュを返す
```

より頑健な実装はたくさんありますが単純には以下の通りです。

```js
const memoize = (f) => {
  const cache = {};

  return (...args) => {
    const argStr = JSON.stringify(args);
    cache[argStr] = cache[argStr] || f(...args);
    return cache[argStr];
  };
};
```

評価を遅延させることによって不純関数を純粋関数に変換できることもあることを気に留めておきましょう。

```js
const pureHttpCall = memoize((url, params) => () => $.getJSON(url, params));
```

ここで興味深いのは http の呼び出しは実際には行われていないということです。代わりに呼ばれた時にそうする関数が返されています。同じ入力に対して常に同じ出力を返すのでこの関数は純粋です。`url` と `params` が与えられた特定の http の呼び出しを行う関数です。

`memorize` 関数はうまく動作し、http の呼び出しの結果をキャッシュせず、生成された関数をキャッシュします。

これはまだそれほど便利ではありませんが、あとでそれを便利にするいくつかの方法を学びます。ここでの重要な情報はどんなに破壊的に見えても全ての関数をキャッシュできるということです。

### 移植性 / 自己説明的

純粋関数は完全に自己完結的です。必要なものは全て恭しく純粋関数に渡されます。ちょっと考えてみてください。これがどのように有益でしょうか？まず初めに、関数の依存関係は明確なので理解しやすいです。水面下でおかしなことが起きていません。

```js
// 不純
const signUp = (attrs) => {
  const user = saveUser(attrs);
  welcomeUser(user);
};

// 純粋
const signUp = (Db, Email, attrs) => () => {
  const user = saveUser(Db, attrs);
  welcomeUser(Email, user);
};
```

この例では純粋関数はその依存関係について正直で正確に何に依存するのかを伝えなければならないことが示されています。単にその引数から、関数は `Db`, `Email`, `attrs` を使いそれが最小限のことを伝えているはずであると知るのです。

あとで単に評価を遅延させることなく関数を純粋関数にする方法を学びますが、ここでの重要な点は純粋な形式は誰が何を知っているかに依存する不純な形式よりもずっと多くを伝えているということです。

他に気づくべきことは、我々は依存関係を "注入する" もしくは引数としてそれを渡すことを強制されているということです。我々のデータベースやメールのクライアントなどをパラメータ化しており、依存関係を渡すことで我々のアプリケーションをより柔軟にしています (あとで見た目よりもより手間をかけなくする方法を学びます)。もし異なる Db を使用することを選択したら、それを使って関数を呼べば良いだけです。もしこの再利用可能な関数を再利用して新しいアプリケーションを書きたい場合は、その時の `Db` と `Email` をこの関数に渡せば良いだけです。

JavaScript において移植性とは関数をシリアライズしソケット越しに送ることを意味します。それはアプリケーションコードの全てをウェブワーカーで動作させることを意味します。移植性は強力な特性です。

状態、依存関係、使用できる作用を通じて環境に深く結びついている命令的プログラミングの "典型的な" 手続きに比べ、純粋関数は望みの場所で動作可能です。

新しいアプリケーションに手続きを最後にコピーしたのはいつですか？Erlang の作成者ジョー・アームストロングのお気に入りの引用の一つ、"オブジェクト指向言語の問題はそれを取り巻く全ての環境を持ってしまっているということです。バナナを欲しかったのだけれど、得られたのはバナナをつかんでいるゴリラ。。。そしてジャングル全体です。"

### テストのしやすさ

次に、純粋関数をテストするのはずっと容易であることに気が付きます。"本物の" 決済システムを模倣したり、それぞれのテストで状態を設定しなくても大丈夫です。単に関数に入力を与え出力を検証するだけです。

実際、関数型プログラミングのコミュニティが生成された入力で関数を叩き出力の特性を検証する新しいテストツールの先駆者となっていることが分かります。この本の範囲外ですが、*Quickcheck* - 純粋関数の環境のために設計されたテストツール - を試すことを強く推奨します。

### 推論のしやすさ

純粋関数で実装する時の最も大きな利点は *参照透過性* であると多くの人は信じています。コードのある場所がその評価された値でプログラムの動作を変えることなく置き換え可能な時、それは参照的に透過です。

純粋関数は副作用がないので、プログラムの動作にその出力値を通してのみ影響を及ぼすことが可能です。さらに、出力は入力を使ってのみ計算され得るので、純粋関数は常に参照透過性を保持します。例を見てみましょう。

```js
const { Map } = require('immutable');

// Aliases: p = player, a = attacker, t = target
const jobe = Map({ name: 'Jobe', hp: 20, team: 'red' });
const michael = Map({ name: 'Michael', hp: 20, team: 'green' });
const decrementHP = p => p.set('hp', p.get('hp') - 1);
const isSameTeam = (p1, p2) => p1.get('team') === p2.get('team');
const punch = (a, t) => (isSameTeam(a, t) ? t : decrementHP(t));

punch(jobe, michael); // Map({name:'Michael', hp:19, team: 'green'})
```

`decrementHP`, `isSameTeam`, `punch` はいずれも純粋関数なので参照透過的です。コードを推論するために "同じもの" を置き換える *等価推論* というテクニックを使うことができます。それはプログラム的な評価の癖を考慮することなく手動でコードを評価するようなことです。参照透過性を使って、ちょっとこのコードを試してみましょう。

まず `isSameTeam` 関数を当てはめます。

```js
const punch = (a, t) => (a.get('team') === t.get('team') ? t : decrementHP(t));
```

データは変更されないので、チームを実際の値に置き換えます。

```js
const punch = (a, t) => ('red' === 'green' ? t : decrementHP(t));
```

これは false だと分かるので、if 節全体を削除します。

```js
const punch = (a, t) => decrementHP(t);
```

そしてもし `decrementHP` を当てはめた場合、この場合は punch は `hp` を 1 減らす呼び出しになることがわかります。

```js
const punch = (a, t) => t.set('hp', t.get('hp') - 1);
```

コードについて推論するこの能力はコードを一般的にリファクタリングしたり理解する時に大変素晴らしいものになります。実際、カモメの群れプログラムをリファクタリングするときにこのテクニックが用いられました。加算と乗算の性質を結びつけるために等価推論が用いられました。この本を通して我々はこのテクニックを使っていきます。

### 並列コード

ついに最後の一撃ですが、共有メモリにアクセスする必要がなく定義により副作用による競合状態を持ち得ないので、純粋関数は並列に走らせることが可能です。

不純な関数を取り扱うのが複雑であるために避けられているように見えマスが、ブラウザのウェブワーカーと同様、これはスレッドを使ったサーバサイドの js 環境でも可能です。

## まとめ

何が純粋関数であり関数型プログラマーとしてなぜそれがクールなのかを見てきました。これから我々は全ての関数を純粋な方法で書く努力することになります。そうするのにはいくつか追加の道具が必要とされますが、まずは純粋なコードと不純なものを分けることを試みます。

純粋関数でプログラムを書くのは追加の道具がないとしんどいです。至るところで引数を渡してデータを取り扱わなければなりません。状態ましてや作用を使うことを禁止されいるので。この自虐的なプログラムを書くにはどうしたらよいのでしょうか？カリーと呼ばれる新しい道具を獲得しましょう。

[第 4 章: カリー化](ch04-ja.md)
