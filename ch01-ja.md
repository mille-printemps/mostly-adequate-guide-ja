# 第 1 章: これまで何をしてきていますか？

## 導入

こんにちは！教授のフランクリン・フリスビーです。お目にかかれて嬉しいです。これからあなたに少しばかり関数型プログラミングを教えることになっていて、少しの間ご一緒することになります。私についてはもうよいのですが、あなたについてはどうでしょう？私があなたに望むのは、少なくとも少しは JavaScript 言語について知っており、オブジェクト指向を少し経験しており、現役のプログラマーを自任していることです。あなたは昆虫学の博士号を持っている必要はありません。いくつかバグを発見し駆除する方法を知っていればよいです。

私はあなたが関数型プログラミングの知識を持っていることを仮定しません。仮定したときに何が起きるのか我々双方は知っているので。しかしながら、あなたが可変な状態や制限のない副作用や節操のない設計に関わった時に持ち上がる好ましくない状況に遭遇したことがあると私は期待しています。さて我々双方の紹介が済みました。進めましょう。

この章の目的は私たちが関数型プログラムを書くときに何を目指しているのかをあなたに感じてもらうことです。この後の章を理解するためには、何がプログラムを *関数的* にするのかについて、いくらか知っておく必要があります。さもなければ、目的もなく書き散らし、何としてもオブジェクトを避けようとすることになるでしょう。実に不器用な努力です。我々にはコードを投げつける明確な的が必要ですし、波が荒い時には天球儀が必要です。

今日、プログラミングのための一般的な原則がいくつかあります。アプリケーションの暗いトンネル内を導く様々な信条です。DRY (繰り返すな)、YAGNI (要らねえよ)、疎結合密結合、驚き最小の原則、単一責務など。

私が何年も耳にしたこうしたガイドラインの一つひとつを挙げてあなたをやっつけようとしているわけではありません。重要なのは、それらは我々の究極的な目的に単に接しているだけではありますが、関数型の決め事に含まれているということです。先に進む前に現時点であなたに感じていただきたいことは、我々がキーボードを叩く時の目的、関数型の楽園です。

<!--BREAK-->

## 短い出会い

ちょっと馬鹿げたことから初めてみましょう。ここにカモメアプリケーションがあります。カモメの群れが合わさるとより大きな群れになり、群れが繁殖すると繁殖している相手の群れのカモメの数ぶん群が増加します。以下は良いオブジェクト指向のコードではないと言うことを覚えておいてください。これは今風の課題に基づいたアプローチの危険性を浮き彫りにするためのものです。注意してください。

```js
class Flock {
  constructor(n) {
    this.seagulls = n;
  }

  conjoin(other) {
    this.seagulls += other.seagulls;
    return this;
  }

  breed(other) {
    this.seagulls = this.seagulls * other.seagulls;
    return this;
  }
}

const flockA = new Flock(4);
const flockB = new Flock(2);
const flockC = new Flock(0);
const result = flockA
  .conjoin(flockC)
  .breed(flockB)
  .conjoin(flockA.breed(flockB))
  .seagulls;
// 32
```
一体誰がこんな恐ろしく忌まわしいものを作ったのでしょうか？内部の状態は変化し追い続けるのが非合理なほど困難です。そして、おやまあ、答えが間違ってさえいます。答えは `16` のはずですが、緊張した `flockA` は処理中常に変化しました。かわいそうな `flockA`。これは I.T. の無政府状態です！これは野生動物の算術です！

もしあなたがこのプログラムを理解していないとしても大丈夫です。私も理解していません。ここで覚えるべき点は、こんな小さな例においてさえ状態と可変の値は追うのが大変ということです。

もう一度やってみましょう。次はより関数的なアプローチを使っています。


```js
const conjoin = (flockX, flockY) => flockX + flockY;
const breed = (flockX, flockY) => flockX * flockY;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    conjoin(breed(flockB, conjoin(flockA, flockC)), breed(flockA, flockB));
// 16
```

今度は正しい答えを得ました。ずっと少ないコードでです。関数のネストはちょっと混乱します (我々は第 5 章でこの状況を直します)。より良くなりましたが、もう少し掘り下げてみましょう。スペードをスペードと呼ぶには利点があります。もし我々のカスタム関数をより注意深く精査していれば、我々は単に加算 (`conjoin`) と乗算 (`breed`) をしていただけだと発見できたでしょう。

それら2つの関数の名前以外、特別なことは何もありません。それらの真の姿を明かすために、我々のカスタム関数の名前を `multiply` と `add` に変えてみましょう。

```js
const add = (x, y) => x + y;
const multiply = (x, y) => x * y;

const flockA = 4;
const flockB = 2;
const flockC = 0;
const result =
    add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));
// 16
```

そしてこれにより、我々は先人の知識を得ます。

```js
// 結合性
add(add(x, y), z) === add(x, add(y, z));

// 交換性
add(x, y) === add(y, x);

// 単位元
add(x, 0) === x;

// 分配性
multiply(x, add(y,z)) === add(multiply(x, y), multiply(x, z));
```
そしてこれらの古くて信頼のおける数学的な性質は重宝されるはずです。あなたがこれらの性質をすぐに思い出せなかったとしても心配することはありません。我々の多くにとってこれらの算術則を学習してからしばらく時間が経っています。これらの性質を使ってカモメプログラムを単純化できるか見てみましょう。

```js
// 元のプログラム
add(multiply(flockB, add(flockA, flockC)), multiply(flockA, flockB));

// 単位元を適用して余分な加算を取り除く
// (add(flockA, flockC) == flockA)
add(multiply(flockB, flockA), multiply(flockA, flockB));

// 分配性を適用して結果を得る
multiply(flockB, add(flockA, flockA));
```

素晴らしい！我々が呼び出している関数以外はカスタムコードを書く必要がありませんでした。ここでは完全のために `add` と `multiply` を定義しましたが、実際にはそうする必要はありません。`add` と `multiply` を提供しているライブラリが存在するのは確実です。

"こんな数学的な例を前面に出すなんてあなたは案山子か" とか "実際のプログラムはこんなに単純ではないし、このように結果を導けない" とあなたは考えているかもしれません。私がこの例を選んだのは我々のほとんどが加算と乗算についてすでに知っているからです。ですので、ここでは数学が我々にとってどれほど便利であるかを理解するのは容易です。

絶望しないでください。この本を通じて我々は圏論、集合論、ラムダ計算に触れ、我々のカモメの群れの例のような同じ上質な単純さと結果を達成している現実世界の例を記述して行きます。あなたは数学者である必要もありません。あなたが "通常の" フレームワークや API を使っているかのように自然かつ容易です。

我々が日常的なアプリケーションの全体を上のように関数的に書くことができると聞くと驚かれるもしれません。健全な性質を持つプログラム。簡潔で容易に結果を導けるプログラム。毎回車輪の再発明をしないプログラム。もしあなたが犯罪者なら無法は良いですが、この本では数学の法則を認め従います。

我々は全ての断片が礼儀正しく組み合わさるような理論を用います。我々は特定の問題を汎化な組み合わせ可能な断片として提示し、その後それらの性質を探索します。命令的なプログラミングの "なんでもあり" アプローチよりも少し鍛錬が必要となるでしょう (後で "命令的" の正確な定義について見ていきますが、とりあえず関数型プログラミング以外のものと考えてください)。原理的で数学的な枠組みの中で動くことによりもたらされる見返りにあなたは本当に驚愕するでしょう。

関数的なものが目指すところについて少し見てきましたが、我々が目指すところに向けて本当に出発する前に理解しておくべきいくつかの具体的な概念があります。

[第 2 章: 第一級関数](ch02-ja.md)
