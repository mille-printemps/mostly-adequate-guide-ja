# 第 7 章: Hindley-Milner と私

## あなたの型は？

もしあなたにとって関数型プログラミングの世界が初めてのものなら、型署名に深く関わることになるまで時間はかからないでしょう。型は異なるバックグラウンドを持つ人々が簡潔かつ効果的にコミュニケーションするためのメタ言語です。ほとんどの場合、"Hindley-Milner" というシステムで書かれており、この章で一緒に見ていくことになります。

純粋関数を扱うとき、型署名には英語では表現できない表現力があります。型署名は関数の秘密を耳元で囁きます。ひとつのコンパクトな行で動作や意図を明らかにします。それらから "タダ定理" を導出することができます。型は推論されるため明示的な型注釈は必要ありません。高い精度を持つこともできますし一般的で抽象的なままにすることもできます。コンパイル時のチェックに役立つだけでなく利用可能な最高のドキュメントになります。型署名は最初に期待するよりもはるかに関数型プログラミングに重要な役割を果たします。

JavaScript は動的言語ですが型を完全に避けるわけではありません。我々はまだ文字列、数値、ブール値などを扱っています。ただし言語レベルでの統合はないためこの情報を頭の中で保持しています。文書化のために署名を使用しているため、コメントを使用して目的を果たすことができます。

JavaScript 向けの型チェックツールの [Flow](https://flow.org/) や型指定された方言である [TypeScript](https://www.typescriptlang.org/) などがあります。この本の目的は関数型コードを書くためのツールを装備することであり、関数型言語全体で使用される標準の型システムに従うことにします。

## 暗号的なものからの物語

数学書の埃を被ったページから、論文の広大な海から、土曜の朝のブログ投稿の中、そしてソースコードの中に、Hindley-Milner 型署名が見つかります。このシステムは非常にシンプルですが、ちょっとした説明とその小さな言語を完全に吸収するために少し練習が必要となります。

```js
// capitalize :: String -> String
const capitalize = s => toUpperCase(head(s)) + toLowerCase(tail(s));

capitalize('smurf'); // 'Smurf'
```
ここでは、`capitalize` は `String` を受け取り、`String` を返す関数です。実装は気にしないでください。我々が興味を持っているのは型署名です。

Hindley-Milner では関数は `a -> b` として書かれ、`a` と `b` は任意の型の変数です。つまり `capitalize` の型署名は、"`String` から `String` への関数" と読むことができます。言い換えると、`String` を入力として受け取り、`String` を出力として返します。

さらにいくつかの関数の型署名を見てみましょう:

```js
// strLength :: String -> Number
const strLength = s => s.length;

// join :: String -> [String] -> String
const join = curry((what, xs) => xs.join(what));

// match :: Regex -> String -> [String]
const match = curry((reg, s) => s.match(reg));

// replace :: Regex -> String -> String -> String
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

`strLength` is the same idea as before: we take a `String` and return you a `Number`.

`strLength` は前述の考え方と同じです。`String` を取り `Number` を返します。

その他の関数は最初は混乱するかもしれません。詳細を完全に理解しなくても、最後の型を単に戻り値として見ることができます。つまり `match` は "`Regex` と`String` を取り、`[String]` を返す関数" と解釈できます。しかしここで面白いことが起こっているので、許されるのなら少し説明したいと思います。

`match` では型署名を次のようにグループ化することができます。

```js
// match :: Regex -> (String -> [String])
const match = curry((reg, s) => s.match(reg));
```

そうです、最後の部分を括弧でグループ化するとより詳細な情報が明らかになります。これは `Regex` を受け取り、`String` から `[String]` への関数を返す関数であることが分かります。カリー化されているのでこれは実際に正しいです。`Regex` を与えると、`String` 引数を待っている関数が返されます。もちろんこの方法で考える必要はありませんが、なぜ最後の型が返されるのかを理解することは良いことです。

```js
// match :: Regex -> (String -> [String])
// onHoliday :: String -> [String]
const onHoliday = match(/holiday/ig);
```

各引数は型署名の先頭から 1 つの型を取り出します。`onHoliday` はすでに `Regex` を持つ `match` です。

```js
// replace :: Regex -> (String -> (String -> String))
const replace = curry((reg, sub, s) => s.replace(reg, sub));
```

`replace` に完全な括弧を付けるとその記述が多少うるさく冗長な場合があるため省略します。すべての引数を一度に与えることができるので、こう考えた方がより簡単でしょう。`replace` は `Regex`, `String`, もう 1 つの `String` を受け取り、`String` を返す。

最後にいくつか。

```js
// id :: a -> a
const id = x => x;

// map :: (a -> b) -> [a] -> [b]
const map = curry((f, xs) => xs.map(f));
```

`id` 関数は、任意の型 `a` を取り、同じ型 `a` の何かを返します。コードの中で使われているのと同じように型に対して変数を使うことができます。型の変数名には `a` や `b` などの慣習的な名前がありますが、任意の名前に置き換えることができます。同じ変数である場合は同じ型である必要があります。重要な規則なので繰り返します。 `a -> b` は任意の型 `a` から任意の型 `b` になりますが、`a -> a` は同じ型である必要があります。たとえば、`id` は `String -> String` または `Number -> Number` のようになる場合がありますが、`String -> Bool` とはなりません。

同様に `map` も型の変数を使用しますが、今回は `a` と同じ型であるかどうかは不明な `b` を導入しています。このように読み取ることができます。`map` は任意の型 `a` から同じ型または異なる型 `b` への関数を取り、さらに `a` の配列を取り `b` の配列を返します。

この型署名の表現力の美に圧倒されているといいですね。それは文字通り関数がほぼ一字一句何をするかを私たちに伝えます。`a` から `b` への関数、`a` の配列が結果として `b` の配列を返します。その関数を各 `a` に対して呼び出す以外には考えられないことです。それ以外のことは大胆な嘘に過ぎません。

型とその含意を理解することができることは、関数型プログラミングの世界で遠くまで行くために必要なスキルです。論文やブログ、ドキュメントなどがより理解しやすくなるだけでなく、型署名自体がその機能についてほとんど講義してくれます。流暢な読み手になるには練習が必要ですが、それに取り組んでいれば RTFM されることなく多くの情報が利用可能になるでしょう。

次のいくつかは自分で解読できるかどうかを確認するためのものです。

```js
// head :: [a] -> a
const head = xs => xs[0];

// filter :: (a -> Bool) -> [a] -> [a]
const filter = curry((f, xs) => xs.filter(f));

// reduce :: ((b, a) -> b) -> b -> [a] -> b
const reduce = curry((f, x, xs) => xs.reduce(f, x));
```

`reduce` はおそらく全ての関数の中でもっとも表現力があるでしょう。しかしそれはやや複雑なものですので苦戦しても自信をなくさないでください。興味のある方のためにここでは英語で説明を試みますが、自分で型署名を分析することがもっとも効果的な学習法です。

えーと、まず型署名を見てみると、最初の引数は `b` と `a` を受け取り `b` を返す関数です。どこからこの `a` と `b` が来るのか？ 続く型署名での引数は `b` と `a` の配列なので、これらの `a` と `b` のそれぞれが関数に入力されると仮定するしかありません。また関数の結果は `b` であることから、渡された関数の最終的な呪術が出力値になると考えられます。`reduce` が何をするかを知っているのであれば上記の調査は正確であると言えます。

## 可能性を絞り込む

型変数が導入されると、興味深い性質である *[パラメトリシティ](https://en.wikipedia.org/wiki/Parametricity)* が現れます。この性質は関数が *すべての型に対して均一に動作する* というものです。以下を調べてみましょう。

```js
// head :: [a] -> a
```

`head` を見ると、`[a]` を `a` に変換することができることがわかります。具体的な型である `array` 以外に利用可能な情報がないため、その機能性は配列のみに限定されます。`a` という変数について何ができるのでしょうか？ それについて何も知らない場合この関数は何ができるのでしょうか？ 言い換えると `a` は *特定の* 型であることはできず、*任意の* 型であり得ることを意味しますが、すなわち *すべての* 型に対して均一に機能する関数になります。これが *パラメトリシティ* と呼ばれるものです。実装を推測すると、配列から最初、最後、または不特定の要素を取得するというのが唯一の合理的な仮定になります。`head` という名前が私たちにヒントを与えるはずです。

もう一つ。

```js
// reverse :: [a] -> [a]
```

型署名のみから `reverse` が何をしているのか分かるでしょうか？ 再度言及しますが `a` に関する具体的な情報は何もありません。`a` を別の型に変換することはできないですし、もしくは `b` を導入することになるでしょう。ソートできますか？ 全ての可能なタイプをソートするための十分な情報があるわけではないのでできません。再配置することはできますか？ はい、その可能性はありますが完全に予測可能な方法で行わなければなりません。他の可能性としては、要素を削除または複製することを決めるかもしれません。いずれにしても多相の型によって可能な動作は大幅に狭まります。

このように可能性が狭めれば、[Hoogle](https://hoogle.haskell.org/) のような型署名の検索エンジンを使用して、探している関数を見つけることができます。型署名に密に詰め込まれた情報は非常に強力です。

## 定理にある自由

実装可能性を導出するだけでなくこの種の推論は私たちに *タダ定理* をもたらします。以下に、[Wadlerの論文](http://ttic.uchicago.edu/~dreyer/course/papers/wadler.pdf) から直接引用したいくつかのランダムな定理の例があります。

```js
// head :: [a] -> a
compose(f, head) === compose(head, map(f));

// filter :: (a -> Bool) -> [a] -> [a]
compose(map(f), filter(compose(p, f))) === compose(filter(p), map(f));
```

これらの定理を得るためにコードを書く必要はありません。型から直接導かれます。最初の定理は、配列の `head` を取得しそれにある関数 `f` を実行するのは、全ての要素に `map(f)` を適用してから結果の `head` を取るのと同等であり、偶然にも後者よりもはるかに速いことを示しています。

これを常識的なことだと思うかもしれません。しかし最後に私がチェックした限りではコンピュータは常識を持っていません。実際、これらの種類のコード最適化を自動化するための形式的な方法が必要です。数学には直感を形式化する方法があり、それはコンピュータの論理の確固たる地形で役立ちます。

`filter` の定理も同様です。`f` と `p` を合成してフィルタリングするものをチェックし、実際に `map` を介して `f` を適用する場合 (`filter` は要素を変換しないためその型署名では `a` は変更されないことに注意してください)、常に `f` をマップしてから条件 `p` で結果をフィルタリングするのと同等であると言えます。

これらはただの2つの例ですが、この推論を任意の多相型署名に適用することができそれは常に成立します。JavaScript では書き換え規則を宣言するためのツールがいくつかあります。 `compose` 関数自体を介してこれを行うこともできます。こうした推論からの結果は得やすく可能性は無限です。

## 制約

最後に注意すべきことは型をあるインタフェースに制限できることです。

```js
// sort :: Ord a => [a] -> [a]
```

ここで太い矢印の左側に表示されているのは事実の声明です。つまり `a` は `Ord` でなければなりません。言い換えると `a` は `Ord` インタフェースを実装しなければなりません。`Ord` とは何であり、どこから来たのでしょうか？ 型付けされた言語では値を並べ替えることができることを示す定義済みのインタフェースです。これは `a` についてのさらなる情報と `sort` 関数が何であるかを教えているだけでなくドメインを制限しています。これらのインタフェース宣言を *型制約* と呼びます。

```js
// assertEqual :: (Eq a, Show a) => a -> a -> Assertion
```

ここでは `Eq` と `Show` の2つの制約があります。これにより `a` の等価性を確認し等しくない場合は差分を表示することができます。

後の章で制約の例をさらに見て行けば、そのアイデアがより明らかになっていくはずです。

## まとめ

Hindley-Milner 型署名は関数型の世界では広く使われています。読み書きが簡単であるにもかかわらず、型署名だけでプログラムを理解する技術を習得するには時間がかかります。今後はコードの各行に型署名を追加します。

[第 8 章: タッパーウェア](ch08-ja.md)
